## Установка
производится с официального сайта
https://www.python.org/downloads/ 

проверка версии
```PowerShell
python --version
py --version
```

переход на другую версию
```PowerShell
python -(номер верии)
python --version
```


```Python
name = input("введите имя: ")
print("Привет, ", name)
```
## виртуальное окружение
возникновение проблем при несовместимости версий

открыть терминал и ввести 
```PowerShell
python3 -m venv .folder
```

## запуск в консоли
нажать F5 или набрать команду в терминале

```PowerShell
python <имя файла>
```


## оформление кода
* для оформления используются отсупы и табуляция
* для вложенного кода используется перенос и отступ строки
* регистрозависимость
* camelCase и snake_case
* комментирование отдельной строки #
* комментирование блока кода ''' блок текста '''
* коментирование горячая клавиша ctrl+K+U

## зарезервированные слова
```Python
False      await      else       import     pass
None       break      except     in         raise
True       class      finally    is         return
and        continue   for        lambda     try
as         def        from       nonlocal   while
assert     del        global     not        with
async      elif       if         or         yield
```


## Инициализация переменных

```Python
name = "Tom"    #инициализация
print(name)     #вывод на консоль >Tom
name = "Bob"    #перезапись
print(name)     #вывод на консоль >Bob
```
объявление переменной без инициализации
```Python
n = None    # пустое значение
```

## Переход на системы счисления

```Python
a = 5       # по умолчанию десятичная система
a = 0b11    # 0b - переход на двоичную
a = 0o7     # 0o - переход на 8ричную
a = 0x0A    # 0x - переход на 16ричную
```

## Типы данных


```Python
a = 5       # целое int
a = 5.5     # вещественное float
a = 1+2j    # комплекное j
a = "Tom"   # строка
a = 'Tom'   # строка

a = ("Tom"
    "Tom")   # многострочный текст

a = '''sdfsdfsf
sfsdfsfsdf
sdsfdfs
sfsfdfs
'''         # многострочный текст
```
Python - язык динамичной типзации, для определения типа данных используют консольную команду type()
```Python
userId = "abc"      # тип str
print(type(userId)) # <class 'str'>
 
userId = 234        # тип int
print(type(userId)) # <class 'int'>
```

## Преобразование типов
```Python
a = "2"
b = 3
c = int(a) + b
print(c)    # 5 


c = float(a) + b
d = str(5.7)       # d = "5.7"
b = int(input('введи первое число: '))
```



## Управляющие последовательности

* \\: позволяет добавить внутрь строки слеш
* \': позволяет добавить внутрь строки одинарную кавычку
* \": позволяет добавить внутрь строки двойную кавычку
* \n: осуществляет переход на новую строку
* \t: добавляет табуляцию (4 отступа)

```Python
path = r"C:\python\name.txt"    # r - спецсимвол для обозначения пути
```

## Вставка значений
```Python
userName = "Tom"
userAge = 37
user = f"name: {userName}  age: {userAge}"  # f - спецсимвол
print(user)   # name: Tom  age: 37
```

## Арифметика
```Python
print(6 + 2)  # 8
print(6 - 2)  # 4
print(6 * 2)  # 12
print(7 / 2)  # 3.5 - по умолчанию вещественное деление
print(7 // 2)  # 3 - целочисленное деление
print(7 % 2)  # Получение остатка от деления числа 7 на 2. Результат - 1
print(6 ** 2)  # Возводим число 6 в степень 2. Результат - 36

print(round(3/5)) # округление до целых
print(round(3.555, 2)) # округление до 2х знаков 
```

|знак присвоения|описание|
|---|---|
|+=|Присвоение результата сложения|
|-=|Присвоение результата вычитания|
|*=|Присвоение результата умножения|
|/=|Присвоение результата от деления|
|//=|Присвоение результата целочисленного деления|
|**=|Присвоение степени числа|
|%=|Присвоение остатка от деления|



|знак сравнения|описание|
|---|---|
|==|Возвращает True, если оба операнда равны. Иначе возвращает False.|
|!=|Возвращает True, если оба операнда НЕ равны. Иначе возвращает False.|
|> (больше чем)|Возвращает True, если первый операнд больше второго.|
|< (меньше чем)|Возвращает True, если первый операнд меньше второго.|
|>= (больше или равно)|Возвращает True, если первый операнд больше или равен второму.|
|<= (меньше или равно)|Возвращает True, если первый операнд меньше или равен второму.|

|знак |логическая операция|
|---|---|
|x and y|логическое И|
|x or y|логическое ИЛИ|
|not y|логическое НЕ|
|значение in набор_значений (или not in)|возвращает True если значение есть в наборе значений |




## Области видимости

Глобальный контекст подразумевает, что переменная является глобальной, она определена вне любой из функций и доступна любой функции в программе. Например:
```Python
name = "Tom" 
def say_hi():
    print("Hello", name)

def say_bye():
    print("Good bye", name)
 
say_hi()
say_bye()
```
В отличие от глобальных переменных локальная переменная определяется внутри функции и доступна только из этой функции, то есть имеет локальную область видимости:
```Python
def say_hi():
    name = "Sam"
    surname = "Johnson"
    print("Hello", name, surname)
 
 
def say_bye():
    name = "Tom"
    print("Good bye", name)
 
say_hi()
say_bye()
```
Есть еще один вариант определения переменной, когда локальная переменная скрывают глобальную с тем же именем:
```Python
name = "Tom" 
def say_hi():
    name = "Bob"        # скрываем значение глобальной переменной
    print("Hello", name) 
def say_bye():
    print("Good bye", name) 
say_hi()    # Hello Bob
say_bye()   # Good bye Tom
```
Если же мы хотим изменить в локальной функции глобальную переменную, а не определить локальную, то необходимо использовать ключевое слово global:
```Python
name = "Tom"  
def say_hi():
    global  name
    name = "Bob"        # изменяем значение глобальной переменной
    print("Hello", name) 
def say_bye():
    print("Good bye", name) 
say_hi()    # Hello Bob
say_bye()   # Good bye Bob
```
Выражение nonlocal прикрепляет идентификатор к переменной из ближайщего окружающего контекста (за исключением глобального контекста). Обычно nonlocal применяется во вложенных функциях, когда надо прикрепить идентификатор за переменной или параметром окружающей внешней функции. Рассмотрим ситуацию, где это выражение может пригодиться:
```Python
def outer():  # внешняя функция
    n = 5
     def inner():    # вложенная функция
        print(n)
     inner()     # 5
    print(n)
outer()     # 5
```



## списки
элементы можно изменять
```Python
list_1 = []         #объявление списка
list_1 = list()     #объявление списка
list_1 = [1, 2, 3, 4, 5]     #инициализация списка
list_1.append(8)     #добавление нового значения в список
list_1.pop()     #удаление последнего элемента
list_1.pop(index)     #удаление элемента по индексу
list_1.insert(index, value)     #вставка элемента по индексу

```

## кортеж - tuple
элементы в кортеже нельзя менять

```Python
t = ()         #объявление кортежа
v = tuple(v)

```

## словарь - dict
элементы в кортеже нельзя менять

```Python
d = {}         #объявление кортежа
d = dict()

d['ключ'] = 'значение'

dictionary = {'key1' : 'value1', 'key2' : 'value2'}
del dictionary = ['key1']       #удаление элемента
for item in dictionary:
    print('{}: {}'.format(item, dictionary[item]))

```

## множества
элементы в множестве уникальны и не могут повторятся, и не обязательно упорядочены

```Python
q = set()                               #объявления
colors = {'red', 'green', 'blue'}       #инициализация
colors.add('red')                       #не добавится
colors.add('grey')                      #добавится
colors.remove('red')                    #удаление элемента
colors.discard('red')                   #проверка наличия элемента
colors.clear()                          #зачистка множества

c = a.copy()                            #копирование
a = u.union(b)                          #объединение
i = a.intersection(b)                   #поиск пересечений
i = a.difference(b)                     #поиск отличий

b = frozenset(a)                        #заморозка множества для защиты от изменений

```

|тип коллекции|изменяемость|индексированность|уникальность|как создать|
|:----|:----:|:----:|:----:|----:|
|список list| + |+|-|{} list()|
|кортеж tuple|-|+|-|() tuple()|
|строка string|-|+|-|''  ""|
|множество set|+|-|+|{elm1,elm2}  set()|
|неизменное множество frozenset|-|-|+|frozenset()|
|словарь dict|+ элементы, - ключи, + значения |-|+ элементы, + ключи, - значения |{key:value}   dict()|


## List Comprehension (генератор списков)

```Python
#объявление
list_1 = [exp for item in iterable]

#выборка по условию
list_1 = [exp for item in iterable(if conditional)]
```


```Python
#типовое решение
list_1 = []
for i in range(1,101):
    list_1.append(i)
print(list_1)

#альтернатива
list_1 = [i for i in range(1, 101)]
print(list_1)

#только четные
list_1 = [i for i in range(1, 101) if i % 2 == 0]
print(list_1)
```