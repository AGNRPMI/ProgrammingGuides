## Синтаксис

инструкция - команды заключенные в {} скобки

// - обозначение комментария \
/*  */ - закомментировать блок текста \
горячая кнопка ctrl + /

если не работает кириллица необходимо ввести команды:
Console.InputEncoding = Encoding.Unicode;
Console.OutputEncoding = Encoding.Unicode;




---

## настройка консоли

```Csharp
Console.SetCursorPoition(5, 10); // перенос курсора
Console.ForegroundColor = ConsolColor.Yellow; // цвет текста
Console.BackgroundColor = ConsolColor.Yellow; // цвет фона
Console.Clear(); //очистка консоли
Console.WindowHeight = 10; // размер консоли
Console.WindowWidth = 25; // размер консоли
```

## области видимости
- Контекст класса. Переменные, определенные на уровне класса, доступны в любом методе этого класса. Их еще называют глобальными переменными или полями
- Контекст метода. Переменные, определенные на уровне метода, являются локальными и доступны только в рамках данного метода. В других методах они недоступны
- Контекст блока кода. Переменные, определенные на уровне блока кода, также являются локальными и доступны только в рамках данного блока. Вне своего блока кода они не доступны.

## Пространства имен
Обычно определяемые классы и другие типы в .NET не существуют сами по себе, а заключаются в специальные контейнеры - пространства имен. Пространства имен позволяют организовать код программы в логические блоки, поволяют объединить и отделить от остального кода некоторую функциональность, которая связана некоторой общей идеей или которая выполняет определенную задачу.
Одни пространства имен могут включать в себя другие пространства имен
```Csharp
namespace имя_пространства_имен
{
    // содержимое пространства имен
}
```
директиву using можно использовать не только для импорта пространств имен, но и статических классов
```Csharp
System.Console.WriteLine("_");
или
using System;
Console.WriteLine("_");
или
using System.Console;
WriteLine("_");
```
для подключения пространства имен используется ключевое слово using

## модификаторы доступа

|модификатор | описание|
|---|-----|
|private |закрытый или приватный компонент класса или структуры. Приватный компонент доступен только в рамках своего класса или структуры. все компоненты по умолчанию приватны|
|private protected |компонент класса доступен из любого места в своем классе или в производных классах, которые определены в той же сборке.|
|file |добавлен в версии C# 11 и применяется к типам, например, классам и структурам. Класс или структура с такми модификатором доступны только из текущего файла кода.|
|protected |такой компонент класса доступен из любого места в своем классе или в производных классах. При этом производные классы могут располагаться в других сборках.|
|internal |компоненты класса или структуры доступен из любого места кода в той же сборке, однако он недоступен для других программ и сборок.|
|protected internal| совмещает функционал двух модификаторов protected и internal. Такой компонент класса доступен из любого места в текущей сборке и из производных классов, которые могут располагаться в других сборках.|
|public |публичный, общедоступный компонент класса или структуры. Такой компонент доступен из любого места в коде, а также из других программ и сборок.|
|required| обозначает необходимую инициализацию поля |
```Csharp
class State
{
    // все равно, что private string defaultVar;
    string defaultVar ="default";
    // поле доступно только из текущего класса
    private string privateVar = "private";
    // доступно из текущего класса и производных классов, которые определены в этом же проекте
    protected private string protectedPrivateVar = "protected private";
    // доступно из текущего класса и производных классов
    protected string protectedVar = "protected";
    // доступно в любом месте текущего проекта
    internal string internalVar = "internal";
    // доступно в любом месте текущего проекта и из классов-наследников в других проектах
    protected internal string protectedInternalVar = "protected internal";
    // доступно в любом месте программы, а также для других программ и сборок
    public string publicVar = "public";
 
    // по умолчанию имеет модификатор private
    void Print() => Console.WriteLine(defaultVar);
 
    // метод доступен только из текущего класса
    private void PrintPrivate() => Console.WriteLine(privateVar);
 
    // доступен из текущего класса и производных классов, которые определены в этом же проекте
    protected private void PrintProtectedPrivate() => Console.WriteLine(protectedPrivateVar);
 
    // доступен из текущего класса и производных классов
    protected void PrintProtected() => Console.WriteLine(protectedVar);
 
    // доступен в любом месте текущего проекта
    internal void PrintInternal() => Console.WriteLine(internalVar);
 
    // доступен в любом месте текущего проекта и из классов-наследников в других проектах
    protected internal void PrintProtectedInternal() => Console.WriteLine(protectedInternalVar);
 
    // доступен в любом месте программы, а также для других программ и сборок
    public void PrintPublic() => Console.WriteLine(publicVar);

    // поле только для чтения
    public readonly string HomePlanet = "Earth";

    // разделение класса на части
    public partial class Person {}

    // required модификатор
    public class Book
    {
        public required string Isbn {get; set;}
        public string Title {get; set;}
    }
}
```



## свойства
Кроме обычных методов в языке C# предусмотрены специальные методы доступа, которые называют свойства. Они обеспечивают простой доступ к полям классов и структур, узнать их значение или выполнить их установку.
Вначале определения свойства могут идти различные модификаторы, в частности, модификаторы доступа. Затем указывается тип свойства, после которого идет название свойства. Полное определение свойства содержит два блока: get и set.

В блоке get выполняются действия по получению значения свойства. В этом блоке с помощью оператора return возвращаем некоторое значение.

В блоке set устанавливается значение свойства. В этом блоке с помощью параметра value мы можем получить значение, которое передано свойству.

Блоки get и set еще называются акссесорами или методами доступа (к значению свойства), а также геттером и сеттером.
```Csharp
[модификаторы] тип_свойства название_свойства
{
    get { действия, выполняемые при получении значения свойства}
    set { действия, выполняемые при установке значения свойства}
}
```

```Csharp
private string favoritePrimaryColor;
public string FavorPrimaryColor
{
    get{
        return favoritePrimaryColor;
    }
    set
    {
        switch (value.ToLower())
        {
            case "red":
            case "gree":
            case "blue":
                favoritePrimaryColor = value;
                break;
            default:
            throw new System.ArgumentException(
                $"{value} is not a primary color." +
                "Choose from: red, green,blue.");
            
        }
    }
}

```


## варианты присвоения
```CSharp
string name; //объявление
name = "TOM"; //присвоение
или 
string name = "Tom";//инициализация
const string Name = "Tom"; // константа
```

camelCase



---

## форматирование
```CSharp
'\n' - перенос строки
'\b' - убрать вредыдущий символ
'\t' - табуляция
'\\' - слеш
Console.WriteLine("Привет \nмир"); // перенос мир
```

интерполяция выполняется с помощью символа ($) в начале и вставки имени переменной в скобки {имя переменной}
```csharp
double numberA = 20
double numberB = 10
Console.WriteLine($"число А={numberA} больше числа В={numberB}"); //число А=20 больше числа В=10
```

конкатенация выполняется с помощью символа (+) 
```csharp
double numberA = 20
double numberB = 10
Console.WriteLine("число А=" + numberA + " больше числа В=" + numberB); //число А=20 больше числа В=10
```

синтаксис сорматирующего элемента, при выравниванию по правому краю значения будут положительными, по левому - отрицательными
{ index [, aligment ] [ : formatingString]}

```csharp
Console.WriteLine(
    format: "{0,-10} {1,6:N0}",
    arg0: applesText,
    arg1: applesCount);
```




---

## тип данных

```Csharp
long l = long.MaxValue; // в подсказке можно увидеть максимальное значение
Console.WriteLine($"default(int) = {default(int)}");// присваивает и выводит значение по умолчанию
```


|тип|описание|
|:-:|---|
|bool bl = true; | истина или ложь|
|byte b = 1; | целое от 0 до 255, занимает 1 байт|
|sbyte sb = -101; | целое от -128 до 127, занимает 1 байт|
|short s = 1; | целое число от -32768 до 32767 и занимает 2 байта|
|ushort us = 1; | целое число от 0 до 65535 и занимает 2 байта|
|int i = 10; | целое число от -2147483648 до 2147483647 и занимает 4 байта|
|uint ui = 10U; | целое число от 0 до 4294967295 и занимает 4 байта|
|long l = -10L; |целое число от –9 223 372 036 854 775 808 до 9 223 372 036 854 775 807 и занимает 8 байт|
|ulong ul = 10UL; |хранит целое число от 0 до 18 446 744 073 709 551 615 и занимает 8 байт|
|float f = 7.5F; | число с плавающей точкой от -3.4*1038 до 3.4*1038 и занимает 4 байта.|
|double d = 7.5; |  число с плавающей точкой от ±5.0*10-324 до ±1.7*10308 и занимает 8 байта|
|decimal dec = 7.5M; | десятичное дробное число. Если употребляется без десятичной запятой, имеет значение от ±1.0*10-28 до ±7.9228*1028, может хранить 28 знаков после запятой и занимает 16 байт|
|char c = 'a'; | одиночный символ в кодировке Unicode и занимает 2 байта.|
|string str = "sdfsf";| хранит набор символов Unicode|
|object j = "asd"; | может хранить значение любого типа данных и занимает 4 байта на 32-разрядной платформе и 8 байт на 64-разрядной платформе|
|var hello = "Hell to World";  | неявная типизация|
|var c = 20; // неявная типизация|


## Программа вывода типа данных и их диапазонов
```Csharp
WriteLine("--------------------------------------------------------------------------");
WriteLine("Type    Byte(s) of memory               Min                            Max");
WriteLine("--------------------------------------------------------------------------");
WriteLine($"sbyte   {sizeof(sbyte),-4} {sbyte.MinValue,30} {sbyte.MaxValue,30}");
WriteLine($"byte    {sizeof(byte),-4} {byte.MinValue,30} {byte.MaxValue,30}");
WriteLine($"short   {sizeof(short),-4} {short.MinValue,30} {short.MaxValue,30}");
WriteLine($"ushort  {sizeof(ushort),-4} {ushort.MinValue,30} {ushort.MaxValue,30}");
WriteLine($"int     {sizeof(int),-4} {int.MinValue,30} {int.MaxValue,30}");
WriteLine($"uint    {sizeof(uint),-4} {uint.MinValue,30} {uint.MaxValue,30}");
WriteLine($"long    {sizeof(long),-4} {long.MinValue,30} {long.MaxValue,30}");
WriteLine($"ulong   {sizeof(ulong),-4} {ulong.MinValue,30} {ulong.MaxValue,30}");
WriteLine($"float   {sizeof(float),-4} {float.MinValue,30} {float.MaxValue,30}");
WriteLine($"double  {sizeof(double),-4} {double.MinValue,30} {double.MaxValue,30}");
WriteLine($"decimal {sizeof(decimal),-4} {decimal.MinValue,30} {decimal.MaxValue,30}");
WriteLine("--------------------------------------------------------------------------");
```


---

## конвертация типов данных
Convert. - из любого типа в любой тип
```csharp
Console.Write("Введите возраст: ");
int age = Convert.ToInt32(Console.ReadLine());
Console.Write("Введите рост: ");
double height = Convert.ToDouble(Console.ReadLine());
Console.Write("Введите размер зарплаты: ");
decimal salary = Convert.ToDecimal(Console.ReadLine());
```
.Parse - из строк в любые данные
```csharp
string str = "5";
int a = int.Parse(str);
```

Алгоритм TryParse

```csharp
string? input = ReadLine(); // если введено 12 то результат по истине, если введено двенадцать - ложь
if (int.TryParse(input, out int count)) Console.WriteLine($"There is {count}")
else Console.WriteLine("I could not parse the input")

```






|Тип| В какие типы безопасно преобразуется|
|----|-----|
|byte |short, ushort, int, uint, long, ulong, float, double, decimal|
|sbyte| short, int, long, float, double, decimal|
|short|int, long, float, double, decimal|
|ushort|int, uint, long, ulong, float, double, decimal|
|int|long, float, double, decimal|
|uint|long, ulong, float, double, decimal|
|long| float, double, decimal|
|ulong|float, double, decimal|
|float|double|
|char|ushort, int, uint, long, ulong, float, double, decimal|

В чем же между ними различия? Для этого надо понять организацию памяти в .NET. Здесь память делится на два типа: стек и куча (heap). Параметры и переменные метода, которые представляют типы значений, размещают свое значение в стеке. Стек представляет собой структуру данных, которая растет снизу вверх: каждый новый добавляемый элемент помещается поверх предыдущего. Время жизни переменных таких типов ограничено их контекстом. Физически стек - это некоторая область памяти в адресном пространстве.

Когда программа только запускается на выполнение, в конце блока памяти, зарезервированного для стека устанавливается указатель стека. При помещении данных в стек указатель переустанавливается таким образом, что снова указывает на новое свободное место. При вызове каждого отдельного метода в стеке будет выделяться область памяти или фрейм стека, где будут храниться значения его параметров и переменных.

Причем если параметр или переменная метода представляет тип значений, то в стеке будет храниться непосредсвенное значение этого параметра или переменной. Например, в данном случае переменные и параметр метода Calculate представляют значимый тип - тип int, поэтому в стеке будут храниться их числовые значения.

Ссылочные типы хранятся в куче или хипе, которую можно представить как неупорядоченный набор разнородных объектов. Физически это остальная часть памяти, которая доступна процессу.


|значение или ссылка|тип данных|
|----|-----|
|Типы значений |    целочисленные типы (byte, sbyte, short, ushort, int, uint, long, ulong)
|Типы значений |    Типы с плавающей запятой (float, double)
|Типы значений |    Тип decimal
|Типы значений |    Тип bool
|Типы значений |    Тип char
|Типы значений |    Перечисления enum
|Типы значений |    Структуры (struct) |
| Ссылочные типы: | Тип object|
| Ссылочные типы: | Тип string|
| Ссылочные типы: | Классы (class)|
| Ссылочные типы: | Интерфейсы (interface)|
| Ссылочные типы: | Делегаты (delegate)|

## Перечисление enum

форма:
```csharp
enum название_перечисления
{
    // значения перечисления
    значение1,
    значение2,
    .......
    значениеN
}
```
Тип влияет на значения, которые могут иметь константы. По умолчанию каждому элементу перечисления присваивается целочисленное значение, причем первый элемент будет иметь значение 0, второй - 1 и так далее. 
```csharp
enum Time : byte // Тип перечисления обязательно должен представлять целочисленный тип (byte, sbyte, short, ushort, int, uint, long, ulong). Если тип явным образом не указан, то по умолчанию используется тип int.
{
    Morning,
    Afternoon,
    Evening,
    Night
}
```
значения можно присвоить явно
```csharp
enum DayTime
{
    Morning = 2,
    Afternoon = Morning,
    Evening = 8,
    Night = 16
}
```


---

## арифметические операции
При выполнении сразу нескольких арифметических операций следует учитывать порядок их выполнения. Приоритет операций от наивысшего к низшему:

* Инкремент, декремент
* Умножение, деление, получение остатка
* Сложение, вычитание
* Для изменения порядка следования операций применяются скобки.

```csharp
int z = x + 12; // 22 сложение
int z = x - 6; // 4 вычитание
int z = x * 5; // 50 умножение

int z = x / 5; // 2 деление целочисленное
double c = a / b; // 3.33333333 деление дробное
double z = x % 4.0; //результат равен 2 остаток от деления

int x1 = 5;
int z1 = ++x1; // z1=6; x1=6
Console.WriteLine($"{x1} - {z1}"); // префиксный инкремент сначала значение переменной x увеличивается на 1, а потом ее значение возвращается в качестве результата операции.
 
int x2 = 5;
int z2 = x2++; // z2=5; x2=6
Console.WriteLine($"{x2} - {z2}"); //постфиксный инкремент: x++ - сначала значение переменной x возвращается в качестве результата операции, а затем к нему прибавляется 1.

// аналогично декремент --х и х-- 
```

---

## логические операции
|оператор| действие|
|:-:|---|
| & |       логическое умножение, проверяются оба условия|
| && |      логическое умножение|
| \| |      логическое сложение, проверяются оба условия|
| \|\| |    логическое сложение|
| ^ |       логическое исключающее ИЛИ|
| ~ |       логическое отрицание или инверсия|
| == |      Сравнивает два операнда на равенство. Если они равны, то операция возвращает true, если не равны, то возвращается false|
| != |      Сравнивает два операнда и возвращает true, если операнды не равны, и false, если они равны.|
| < |       Операция "меньше чем". Возвращает true, если первый операнд меньше второго, и false, если первый операнд больше второго:|
| \> |      Операция "больше чем". Сравнивает два операнда и возвращает true, если первый операнд больше второго, иначе возвращает false:|
| <= |      Операция "меньше или равно". Сравнивает два операнда и возвращает true, если первый операнд меньше или равен второму. Иначе возвращает false.|

альтернативное отрицание
```Csharp
if (!(aliceInPerson is Employee))
или
if (aliceInPersone is not Employee)
```



---

## Сдвиг
* x<<y - сдвигает число x влево на y разрядов. Например, 4<<1 сдвигает число 4 (которое в двоичном представлении 100) на один разряд влево, то есть в итоге получается 1000 или число 8 в десятичном представлении.

* x>>y - сдвигает число x вправо на y разрядов. Например, 16>>1 сдвигает число 16 (которое в двоичном представлении 10000) на один разряд вправо, то есть в итоге получается 1000 или число 8 в десятичном представлении.

---

## операции присваивания
|оператор| действие|
|:-:|---|
| += |      присваивание после сложения. Присваивает левому операнду сумму левого и правого операндов: выражение A += B равнозначно выражению A = A + B|
| -= |      присваивание после вычитания. Присваивает левому операнду разность левого и правого операндов: A -= B эквивалентно A = A - B|
| *= |      присваивание после умножения. Присваивает левому операнду произведение левого и правого операндов: A *= B эквивалентно A = A * B|
| /= |      присваивание после деления. Присваивает левому операнду частное левого и правого операндов: A /= B эквивалентно A = A / B|
| %= |      присваивание после деления по модулю. Присваивает левому операнду остаток от целочисленного деления левого операнда на правый: A %= B эквивалентно A = A % B|
| &= |      присваивание после поразрядной конъюнкции. Присваивает левому операнду результат поразрядной конъюнкции его битового представления с битовым представлением правого операнда: A &= B эквивалентно A = A & B|
| \|= |     присваивание после поразрядной дизъюнкции. Присваивает левому операнду результат поразрядной дизъюнкции его битового представления с битовым представлением правого операнда: A |= B эквивалентно A = A | B|
| ^= |      присваивание после операции исключающего ИЛИ. Присваивает левому операнду результат операции исключающего ИЛИ его битового представления с битовым представлением правого операнда: A ^= B эквивалентно A = A ^ B|
| <<= |     присваивание после сдвига разрядов влево. Присваивает левому операнду результат сдвига его битового представления влево на определенное количество разрядов, равное значению правого операнда: A <<= B эквивалентно A = A << B|
| \>>= |    присваивание после сдвига разрядов вправо. Присваивает левому операнду результат сдвига его битового представления вправо на определенное количество разрядов, равное значению правого операнда: A >>= B эквивалентно A = A >> B|

---

## конструкция if...else


```csharp
string name = "Alex";
 if (name == "Tom")
    Console.WriteLine("Вас зовут Tomas");
else if (name == "Bob")
    Console.WriteLine("Вас зовут Robert");
else if (name == "Mike")
    Console.WriteLine("Вас зовут Michael");
else
    Console.WriteLine("Неизвестное имя");
```

тернарная операция: \
[первый операнд - условие] ? [второй операнд if_true] : [третий операнд if_false]

```csharp
int x=3;
int y=2;
int z = x < y ? (x+y) : (x-y);
Console.WriteLine(z);   // 1
```


---

## конструкция switch

форма:
```csharp
switch (выражение)
{
    case значение1 или "какой то текст" или какой то тип данных и метод:
        код,выполняемый если выражение имеет значение1
        break;
    case значение2: // при получении значения 2 совершается переход в кейс 3 и выполнение его кода
    case значение3:
        код,выполняемый если выражение имеет значение1
        goto case значение1; // переход на другой case
    //.............
    case значениеN:
        код, выполняемый если выражение имеет значениеN
        break;
    default:
        код, выполняемый если выражение не имеет ни одно из выше указанных значений
        break;
    case null:
        код, выполняемый если выражение пустое
        break;
}
```
упрощение оператора switch с помощью выражения switch (при использовании лямбда выражений), убираем слова case и break

```csharp
message = s switch
{
    "значение1 или \"какой то текст\" или какой то тип данных и метод" =>
        (код,выполняемый если выражение имеет значение1),
    "значение2" =>
        (код,выполняемый если выражение имеет значение1),
    "значение3" =>
        (код,выполняемый если выражение имеет значение1),
    //.............
    _ => //дефолтное case
        (код, выполняемый если выражение не имеет ни одно из выше указанных значений),
    null =>
        (код, выполняемый если выражение пустое)
}


```


возвращение значение из switch
```csharp
int DoOperation(int op, int a, int b)
{
    switch (op)
    {
        case 1: return a + b;
        case 2: return a - b;
        case 3: return a * b;
        default: return 0;
    }
}
```

## Обработка исключений

предполагая что оператор может вызвать ошибку, его следует заключить в блок try. Блок catch отработает, если ошибка появится в try
в блоке catch может не быть операций
по алгоритму программа поймает исключение, попробует его преобразовать (в примере кода это не выполняется), затем **продолжит работу**, исключив вылет

```csharp
Console.WriteLine("Before parsing");
Console.Write("what is your age");
string? input = Console.ReadLine();

try
{
    int age = int.Parse(input);
    Console.WriteLine($"you age {age} years old.")
}
catch
{}
Console.WriteLine("After parsing");
```

получение сведений о всех исключениях
```csharp
catch (Exception ex)
{
    Cnsole.WriteLine($"{ex.GetType()} says {ex.Message}");
}
```

использование фильтров со словом when
```csharp
Write("Enter an amount: ");
string? amount = ReadLine();
try
{
    decimal amountValue = decimal.Parse(amount);
}
catch (FormatException) when (amount.Contains("$"))
{
    WriteLine("Amount cannot use the dollar sign!")
}
catch (FormatException) 
{
    WriteLine("Amount must only contain digits!")
}
```


## Проверка переполнения

оператор checked для проверки переполнения
```csharp
try
{
checked
{
    int x = int.MInValue - 1;
    WriteLine($"initial value {x}");
    x++;
    WriteLine($"After incrementing {x}");
    x++;
    WriteLine($"After incrementing {x}");
    x++;
    WriteLine($"After incrementing {x}");
}
}
catch (OverflowException)
{
    WriteLine("The code overflowed but i caught the exception");
}
```

оператор unchecked для **запрета** проверки переполнения
```csharp
unchecked
{
    int y = int.MaxValue + 1;
    WriteLine($"initial value: {y}");
    y--;
    WriteLine($"After decrementing: {y}");
    y--;
    WriteLine($"After decrementing: {y}");
}
```

## Работа с неуправляемыми ресурсами

```Csharp
public class Animal
{
    public Animal()// конструктор
    {
        //выделяем неуправляемые ресурсы
    }
    ~Animal() //финализатор, он же деструктор
    {
        //освобождаем неуправляемые ресурсы
        Dispose(false);
    }
    bool disposed = false;
    public void Dispose()
    {
        Dispose(true);
        //сообщаем сборщику мусора что ему ге нужно вызывать финализатор
        GC.SuppressFinalize(this);
    }
    protected virtual void Dispose(bool disposing)
    {
        if (disposing)
        {
            //освобождаем любые другие управляемые ресурсы
        }
        dsiposed = true
    }
}
```
## Работа с null
включение и отключение функции - допи в начале файла
```Csharp
#nullable disable
#nullable enable
```
испльзование в коде
```Csharp
public? string Building;
public string City = string.Empty;
Building = null;// рабоатет
pubic string Address;
Address = null; //не рабоатет
```

проверка на null
```Csharp
if (thisCouldBeNull != null)
{
    int length = thisCouldBeNull.Length;
}

public void Hire(Person manager, Person employee) // или public void Hire (Person manager!!, Person employee!!)
{if (manager == null)
{
    throw new ArgumentNullException(nameof(manager)); // бросок исключения
}
if (employee == null)
{
    throw new ArgumentNullException(nameof(employee));
}}
```
